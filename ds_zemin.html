<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>2D光学系统模拟器</title>
    <style>
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
            font-family: 'Segoe UI', Arial, sans-serif;
        }
        
        body {
            background-color: #f5f7fa;
            color: #333;
            line-height: 1.6;
            padding: 20px;
            max-width: 1600px;
            margin: 0 auto;
        }
        
        header {
            text-align: center;
            margin-bottom: 30px;
            padding-bottom: 20px;
            border-bottom: 1px solid #ddd;
        }
        
        h1 {
            color: #2c3e50;
            margin-bottom: 10px;
            font-size: 2.5rem;
        }
        
        .subtitle {
            color: #7f8c8d;
            font-size: 1.1rem;
            max-width: 800px;
            margin: 0 auto;
        }
        
        .container {
            display: flex;
            flex-wrap: wrap;
            gap: 20px;
            margin-bottom: 30px;
        }
        
        .control-panel {
            flex: 1;
            min-width: 300px;
            background-color: white;
            border-radius: 10px;
            padding: 20px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.08);
            height: fit-content;
        }
        
        .simulation-area {
            flex: 3;
            min-width: 700px;
            background-color: white;
            border-radius: 10px;
            padding: 15px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.08);
            position: relative;
            overflow: hidden;
        }
        
        .section-title {
            font-size: 1.3rem;
            color: #3498db;
            margin-bottom: 15px;
            padding-bottom: 8px;
            border-bottom: 2px solid #eee;
        }
        
        .control-group {
            margin-bottom: 20px;
        }
        
        .lens-list-container {
            max-height: 300px;
            overflow-y: auto;
            border: 1px solid #eee;
            border-radius: 5px;
            padding: 10px;
            margin-bottom: 15px;
        }
        
        .lens-item {
            background-color: #f8f9fa;
            border-radius: 5px;
            padding: 12px;
            margin-bottom: 10px;
            border-left: 4px solid #3498db;
            transition: all 0.2s;
            cursor: pointer;
        }
        
        .lens-item:hover {
            background-color: #edf4fc;
        }
        
        .lens-item.active {
            border-left-color: #e74c3c;
            background-color: #fef2f2;
        }
        
        .lens-header {
            display: flex;
            justify-content: space-between;
            margin-bottom: 8px;
        }
        
        .lens-name {
            font-weight: 600;
            color: #2c3e50;
        }
        
        .lens-actions button {
            background: none;
            border: none;
            cursor: pointer;
            color: #7f8c8d;
            font-size: 0.9rem;
            margin-left: 5px;
            transition: color 0.2s;
        }
        
        .lens-actions button:hover {
            color: #e74c3c;
        }
        
        .param-group {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
            margin-top: 10px;
        }
        
        .param-item {
            display: flex;
            flex-direction: column;
        }
        
        .param-item label {
            font-size: 0.85rem;
            color: #555;
            margin-bottom: 4px;
        }
        
        .param-item input, .param-item select {
            padding: 8px;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-size: 0.9rem;
        }
        
        .param-item input:focus, .param-item select:focus {
            outline: none;
            border-color: #3498db;
            box-shadow: 0 0 0 2px rgba(52, 152, 219, 0.2);
        }
        
        .button-group {
            display: flex;
            gap: 10px;
            margin-top: 20px;
        }
        
        button {
            padding: 10px 15px;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-weight: 600;
            transition: all 0.2s;
        }
        
        .btn-primary {
            background-color: #3498db;
            color: white;
        }
        
        .btn-primary:hover {
            background-color: #2980b9;
        }
        
        .btn-secondary {
            background-color: #2ecc71;
            color: white;
        }
        
        .btn-secondary:hover {
            background-color: #27ae60;
        }
        
        .btn-danger {
            background-color: #e74c3c;
            color: white;
        }
        
        .btn-danger:hover {
            background-color: #c0392b;
        }
        
        .btn-warning {
            background-color: #f39c12;
            color: white;
        }
        
        .btn-warning:hover {
            background-color: #d68910;
        }
        
        .canvas-container {
            position: relative;
            width: 100%;
            height: 500px;
            background-color: #f8f9fa;
            border-radius: 5px;
            overflow: hidden;
            border: 1px solid #e1e4e8;
        }
        
        #simulationCanvas {
            display: block;
            width: 100%;
            height: 100%;
        }
        
        .canvas-overlay {
            position: absolute;
            top: 10px;
            left: 10px;
            background-color: rgba(255, 255, 255, 0.9);
            padding: 8px 12px;
            border-radius: 5px;
            font-size: 0.9rem;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
            z-index: 10;
        }
        
        .dark-mode .canvas-overlay {
            background-color: rgba(0, 0, 0, 0.8);
            color: white;
        }
        
        .wavelength-control {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-top: 15px;
        }
        
        .wavelength-control label {
            font-size: 0.9rem;
            color: #555;
        }
        
        .wavelength-control input {
            flex: 1;
        }
        
        .info-panel {
            display: flex;
            justify-content: space-between;
            margin-top: 15px;
            font-size: 0.85rem;
            color: #7f8c8d;
        }
        
        .dark-mode .info-panel {
            color: #aaa;
        }
        
        .info-item {
            display: flex;
            align-items: center;
            gap: 5px;
        }
        
        .color-indicator {
            width: 15px;
            height: 15px;
            border-radius: 50%;
            display: inline-block;
        }
        
        footer {
            text-align: center;
            margin-top: 40px;
            padding-top: 20px;
            border-top: 1px solid #ddd;
            color: #7f8c8d;
            font-size: 0.9rem;
        }
        
        @media (max-width: 1100px) {
            .container {
                flex-direction: column;
            }
            
            .simulation-area {
                min-width: 100%;
            }
        }
        
        .json-section {
            margin-top: 30px;
            border-top: 1px solid #eee;
            padding-top: 20px;
        }
        
        .json-textarea {
            width: 100%;
            height: 150px;
            padding: 10px;
            border: 1px solid #ddd;
            border-radius: 5px;
            font-family: monospace;
            font-size: 0.85rem;
            resize: vertical;
            margin-bottom: 10px;
        }
        
        .lens-templates {
            margin-top: 20px;
        }
        
        .template-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 10px;
            margin-top: 10px;
        }
        
        .template-btn {
            padding: 8px;
            background-color: #ecf0f1;
            border: 1px solid #ddd;
            border-radius: 4px;
            cursor: pointer;
            text-align: center;
            transition: all 0.2s;
        }
        
        .template-btn:hover {
            background-color: #d5dbdb;
            border-color: #3498db;
        }
        
        .grid-controls, .ray-controls {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-top: 15px;
            flex-wrap: wrap;
        }
        
        .control-row {
            display: flex;
            align-items: center;
            gap: 10px;
            width: 100%;
        }
        
        .control-row label {
            font-size: 0.9rem;
            color: #555;
            min-width: 80px;
        }
        
        .control-row input, .control-row select {
            flex: 1;
        }
        
        .checkbox-group {
            display: flex;
            align-items: center;
            gap: 5px;
        }
        
        .range-value {
            min-width: 40px;
            text-align: right;
        }
        
        .placeholder-text {
            color: #95a5a6;
            font-style: italic;
            text-align: center;
            padding: 20px;
        }
        
        .dark-mode-toggle {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-top: 15px;
        }
        
        /* 暗色模式样式 */
        .dark-mode .canvas-container {
            background-color: #000;
            border-color: #444;
        }
        
        .dark-mode .control-panel {
            background-color: #2c3e50;
            color: #ecf0f1;
        }
        
        .dark-mode .section-title {
            color: #3498db;
            border-bottom-color: #34495e;
        }
        
        .dark-mode .param-item label {
            color: #bdc3c7;
        }
        
        .dark-mode .lens-item {
            background-color: #34495e;
            color: #ecf0f1;
        }
        
        .dark-mode .lens-item:hover {
            background-color: #3d566e;
        }
        
        .dark-mode .lens-item.active {
            background-color: #4a1c1c;
        }
        
        .dark-mode .template-btn {
            background-color: #34495e;
            border-color: #4a6572;
            color: #ecf0f1;
        }
        
        .dark-mode .template-btn:hover {
            background-color: #3d566e;
        }
        
        .dark-mode .json-textarea {
            background-color: #34495e;
            border-color: #4a6572;
            color: #ecf0f1;
        }
        
        .dark-mode .param-item input, .dark-mode .param-item select {
            background-color: #34495e;
            border-color: #4a6572;
            color: #ecf0f1;
        }
        
        .lens-controls {
            display: flex;
            gap: 10px;
            margin-top: 10px;
        }
        
        .wavelength-range {
            display: flex;
            gap: 10px;
            align-items: center;
        }
        
        .wavelength-range-item {
            flex: 1;
        }
        
        .loading-indicator {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(255, 255, 255, 0.9);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            font-size: 1.2rem;
            color: #3498db;
        }
        
        .dark-mode .loading-indicator {
            background-color: rgba(0, 0, 0, 0.9);
            color: #3498db;
        }
    </style>
</head>
<body>
    <div id="loading" class="loading-indicator">
        正在加载默认配置...
    </div>
    
    <header>
        <h1>2D光学系统模拟器</h1>
        <p class="subtitle">模拟2D光路图，可自由添加、调整镜片参数，支持不同波长光线折射，通过JSON导入导出场景配置</p>
    </header>
    
    <div class="container">
        <div class="control-panel">
            <h2 class="section-title">镜片管理</h2>
            
            <div class="control-group">
                <div class="button-group">
                    <button id="addLensBtn" class="btn-primary">添加新镜片</button>
                    <button id="removeLensBtn" class="btn-danger">删除选中镜片</button>
                </div>
                
                <div class="lens-list-container">
                    <div class="lens-list" id="lensList">
                        <!-- 镜片列表将通过JavaScript动态生成 -->
                    </div>
                </div>
            </div>
            
            <div class="control-group">
                <h3 class="section-title">镜片模板</h3>
                <div class="lens-templates">
                    <p style="font-size: 0.9rem; margin-bottom: 10px; color: #555;">快速添加预设镜片:</p>
                    <div class="template-grid">
                        <div class="template-btn" data-type="convex">凸透镜</div>
                        <div class="template-btn" data-type="concave">凹透镜</div>
                        <div class="template-btn" data-type="plano-convex">平凸透镜</div>
                        <div class="template-btn" data-type="plano-concave">平凹透镜</div>
                        <div class="template-btn" data-type="meniscus">弯月透镜</div>
                        <div class="template-btn" data-type="double-convex">双凸透镜</div>
                    </div>
                </div>
            </div>
            
            <div class="control-group">
                <h3 class="section-title">镜片参数</h3>
                <div id="lensParams">
                    <!-- 镜片参数将通过JavaScript动态生成 -->
                    <p class="placeholder-text">选择一个镜片来编辑参数</p>
                </div>
            </div>
            
            <div class="control-group">
                <h3 class="section-title">镜片显示</h3>
                <div class="lens-controls">
                    <div class="checkbox-group">
                        <input type="checkbox" id="lensOutline" checked>
                        <label for="lensOutline">显示描边</label>
                    </div>
                    <div class="checkbox-group">
                        <label for="lensOpacity">透明度:</label>
                        <input type="range" id="lensOpacity" min="0.1" max="1" step="0.1" value="0.6">
                        <span class="range-value" id="lensOpacityValue">0.6</span>
                    </div>
                </div>
            </div>
            
            <div class="control-group">
                <h3 class="section-title">光线设置</h3>
                <div class="ray-controls">
                    <div class="control-row">
                        <label for="rayDensity">光线数量:</label>
                        <input type="range" id="rayDensity" min="0" max="10000" step="1" value="21">
                        <span class="range-value" id="rayDensityValue">21</span>
                    </div>
                    <div class="control-row">
                        <label for="rayOpacity">透明度:</label>
                        <input type="range" id="rayOpacity" min="0.1" max="1" step="0.1" value="1">
                        <span class="range-value" id="rayOpacityValue">1.0</span>
                    </div>
                    <div class="control-row">
                        <label for="blendMode">混合模式:</label>
                        <select id="blendMode">
                            <option value="normal">正常</option>
                            <option value="additive">相加</option>
                            <option value="screen">滤色</option>
                        </select>
                    </div>
                </div>
                <div class="wavelength-range">
                    <div class="wavelength-range-item">
                        <label for="startWavelength">起始波长 (nm):</label>
                        <input type="range" id="startWavelength" min="400" max="700" step="1" value="450">
                        <span class="range-value" id="startWavelengthValue">450</span>
                    </div>
                    <div class="wavelength-range-item">
                        <label for="endWavelength">结束波长 (nm):</label>
                        <input type="range" id="endWavelength" min="400" max="700" step="1" value="650">
                        <span class="range-value" id="endWavelengthValue">650</span>
                    </div>
                </div>
                <div class="button-group">
                    <button id="simulateBtn" class="btn-secondary">模拟光线</button>
                    <button id="clearRaysBtn" class="btn-warning">清除光线</button>
                </div>
            </div>
            
            <div class="control-group">
                <h3 class="section-title">显示设置</h3>
                <div class="grid-controls">
                    <div class="checkbox-group">
                        <input type="checkbox" id="showGrid" checked>
                        <label for="showGrid">显示网格</label>
                    </div>
                    <label for="gridSize">网格大小:</label>
                    <input type="range" id="gridSize" min="10" max="100" step="5" value="50">
                    <span class="range-value" id="gridSizeValue">50</span>
                </div>
                <div class="dark-mode-toggle">
                    <div class="checkbox-group">
                        <input type="checkbox" id="darkMode">
                        <label for="darkMode">纯黑背景</label>
                    </div>
                </div>
            </div>
            
            <div class="json-section">
                <h3 class="section-title">导入/导出配置</h3>
                <textarea id="jsonConfig" class="json-textarea" placeholder='在此粘贴JSON配置，或导出当前配置'></textarea>
                <div class="button-group">
                    <button id="exportBtn" class="btn-primary">导出配置</button>
                    <button id="importBtn" class="btn-secondary">导入配置</button>
                </div>
            </div>
        </div>
        
        <div class="simulation-area">
            <div class="canvas-container">
                <canvas id="simulationCanvas"></canvas>
                <div class="canvas-overlay">
                    光轴: x = 0 到 1000 | 成像平面: x = 950 | 光线: <span id="rayCount">0</span> 条
                </div>
            </div>
            
            <div class="info-panel">
                <div class="info-item">
                    <div class="color-indicator" style="background-color: #ff0000;"></div>
                    <span>红色光 (长波长, ~700nm)</span>
                </div>
                <div class="info-item">
                    <div class="color-indicator" style="background-color: #00ff00;"></div>
                    <span>绿色光 (中波长, ~550nm)</span>
                </div>
                <div class="info-item">
                    <div class="color-indicator" style="background-color: #0000ff;"></div>
                    <span>蓝色光 (短波长, ~400nm)</span>
                </div>
            </div>
        </div>
    </div>
    
    <footer>
        <p>2D光学系统模拟器 &copy; 2023 | 使用HTML5 Canvas和JavaScript构建 | 仅供教学和模拟使用</p>
    </footer>
    
    <script>
        // 默认配置
        const DEFAULT_CONFIG = {
            "lenses": [
                {
                    "name": "平凸透镜 1",
                    "position": 82.9,
                    "thickness": 40.8,
                    "frontCurve": 100,
                    "backCurve": -200,
                    "refractiveIndex": 1.08,
                    "radius": 69.1
                },
                {
                    "name": "平凸透镜 3",
                    "position": 381.6,
                    "thickness": 33.3,
                    "frontCurve": 200,
                    "backCurve": -200,
                    "refractiveIndex": 1.5,
                    "radius": 78.9
                },
                {
                    "name": "双凸透镜 3",
                    "position": 688.5,
                    "thickness": 25,
                    "frontCurve": 70,
                    "backCurve": -70,
                    "refractiveIndex": 1.52,
                    "radius": 45
                }
            ],
            "simulation": {
                "startWavelength": 400,
                "endWavelength": 700,
                "rayDensity": 321,
                "rayOpacity": 0.2,
                "lensOpacity": 1,
                "showLensOutline": true,
                "blendMode": "additive",
                "showGrid": true,
                "gridSize": 10,
                "darkMode": true
            }
        };
        
        // 全局变量
        let lenses = [];
        let rays = [];
        let selectedLensIndex = -1;
        let canvas, ctx;
        const canvasWidth = 1000;
        const canvasHeight = 500;
        const opticalAxisY = canvasHeight / 2;
        const imagePlaneX = 950;
        let showGrid = true;
        let gridSize = 50;
        let darkMode = false;
        let rayDensity = 21;
        let rayOpacity = 1.0;
        let lensOpacity = 0.6;
        let showLensOutline = true;
        let blendMode = 'normal';
        let autoUpdate = true;
        let startWavelength = 450;
        let endWavelength = 650;
        let lensRadius = 40; // 镜片半径（半高）
        
        // 镜片类 - 完全重构
        class Lens {
            constructor(id, position, thickness, frontCurve, backCurve, refractiveIndex, radius) {
                this.id = id;
                this.name = `镜片 ${id}`;
                this.position = parseFloat(position); // x轴位置
                this.thickness = parseFloat(thickness); // 厚度
                this.frontCurve = parseFloat(frontCurve); // 前表面曲率
                this.backCurve = parseFloat(backCurve); // 后表面曲率
                this.refractiveIndex = parseFloat(refractiveIndex); // 折射率
                this.radius = parseFloat(radius); // 镜片半径（半高）
                
                // 用于光线追迹的缓存数据
                this.frontSurfaceData = null;
                this.backSurfaceData = null;
                this.surfaceCache = null;
            }
            
            // 计算表面方程 - 使用像素检测方法
            calculateSurfaceData() {
                // 如果已经计算过，直接返回缓存
                if (this.surfaceCache) return this.surfaceCache;
                
                const frontX = this.position;
                const backX = this.position + this.thickness;
                const topY = opticalAxisY - this.radius;
                const bottomY = opticalAxisY + this.radius;
                
                // 创建表示表面数据的对象
                this.surfaceCache = {
                    frontPoints: [],
                    backPoints: [],
                    insidePixels: []
                };
                
                // 采样分辨率
                const xStep = 1;
                const yStep = 1;
                
                // 计算前表面点
                for (let x = frontX - this.radius; x <= frontX + this.radius; x += xStep) {
                    if (this.frontCurve === 0) {
                        // 平面表面
                        const y = opticalAxisY;
                        if (x >= frontX - 1 && x <= frontX + 1) {
                            this.surfaceCache.frontPoints.push({x, y: topY});
                            this.surfaceCache.frontPoints.push({x, y: bottomY});
                        }
                    } else {
                        // 曲面表面 - 使用圆的方程
                        const centerX = frontX + this.frontCurve;
                        const radius = Math.abs(this.frontCurve);
                        
                        // 计算在给定x处的y值
                        const dx = x - centerX;
                        if (Math.abs(dx) <= radius) {
                            const dy = Math.sqrt(radius * radius - dx * dx);
                            const y1 = opticalAxisY - dy;
                            const y2 = opticalAxisY + dy;
                            
                            // 检查是否在镜片高度范围内
                            if (y1 >= topY && y1 <= bottomY) {
                                this.surfaceCache.frontPoints.push({x, y: y1});
                            }
                            if (y2 >= topY && y2 <= bottomY) {
                                this.surfaceCache.frontPoints.push({x, y: y2});
                            }
                        }
                    }
                }
                
                // 计算后表面点
                for (let x = backX - this.radius; x <= backX + this.radius; x += xStep) {
                    if (this.backCurve === 0) {
                        // 平面表面
                        const y = opticalAxisY;
                        if (x >= backX - 1 && x <= backX + 1) {
                            this.surfaceCache.backPoints.push({x, y: topY});
                            this.surfaceCache.backPoints.push({x, y: bottomY});
                        }
                    } else {
                        // 曲面表面 - 使用圆的方程
                        const centerX = backX + this.backCurve;
                        const radius = Math.abs(this.backCurve);
                        
                        // 计算在给定x处的y值
                        const dx = x - centerX;
                        if (Math.abs(dx) <= radius) {
                            const dy = Math.sqrt(radius * radius - dx * dx);
                            const y1 = opticalAxisY - dy;
                            const y2 = opticalAxisY + dy;
                            
                            // 检查是否在镜片高度范围内
                            if (y1 >= topY && y1 <= bottomY) {
                                this.surfaceCache.backPoints.push({x, y: y1});
                            }
                            if (y2 >= topY && y2 <= bottomY) {
                                this.surfaceCache.backPoints.push({x, y: y2});
                            }
                        }
                    }
                }
                
                // 计算镜片内部像素
                // 简化为矩形区域，实际应该根据前后表面形状计算
                for (let x = Math.max(0, frontX); x <= Math.min(canvasWidth, backX); x += xStep) {
                    for (let y = Math.max(0, topY); y <= Math.min(canvasHeight, bottomY); y += yStep) {
                        // 简化：只要在矩形区域内且在前后表面之间，就认为是镜片内部
                        if (this.isPointInsideLens(x, y)) {
                            this.surfaceCache.insidePixels.push({x, y});
                        }
                    }
                }
                
                return this.surfaceCache;
            }
            
            // 判断点是否在镜片内部
            isPointInsideLens(x, y) {
                const frontX = this.position;
                const backX = this.position + this.thickness;
                const topY = opticalAxisY - this.radius;
                const bottomY = opticalAxisY + this.radius;
                
                // 基本检查：是否在边界矩形内
                if (x < frontX || x > backX || y < topY || y > bottomY) {
                    return false;
                }
                
                // 检查是否在前表面右侧
                if (this.frontCurve === 0) {
                    // 平面表面，直接检查
                    if (x < frontX) return false;
                } else {
                    // 曲面表面 - 使用圆的方程
                    const frontCenterX = frontX + this.frontCurve;
                    const frontRadius = Math.abs(this.frontCurve);
                    const frontDistance = Math.sqrt((x - frontCenterX) ** 2 + (y - opticalAxisY) ** 2);
                    
                    // 根据曲率正负判断
                    if (this.frontCurve > 0) {
                        // 凸面向前，点应该在圆外
                        if (frontDistance < frontRadius) return false;
                    } else {
                        // 凹面向前，点应该在圆内
                        if (frontDistance > frontRadius) return false;
                    }
                }
                
                // 检查是否在后表面左侧
                if (this.backCurve === 0) {
                    // 平面表面，直接检查
                    if (x > backX) return false;
                } else {
                    // 曲面表面 - 使用圆的方程
                    const backCenterX = backX + this.backCurve;
                    const backRadius = Math.abs(this.backCurve);
                    const backDistance = Math.sqrt((x - backCenterX) ** 2 + (y - opticalAxisY) ** 2);
                    
                    // 根据曲率正负判断
                    if (this.backCurve > 0) {
                        // 凸面向后，点应该在圆内
                        if (backDistance > backRadius) return false;
                    } else {
                        // 凹面向后，点应该在圆外
                        if (backDistance < backRadius) return false;
                    }
                }
                
                return true;
            }
            
            // 绘制镜片 - 使用像素检测方法
            draw(ctx) {
                // 计算表面数据
                const surfaceData = this.calculateSurfaceData();
                
                // 保存上下文状态
                ctx.save();
                
                // 设置透明度
                ctx.globalAlpha = lensOpacity;
                
                // 绘制镜片内部区域
                if (surfaceData.insidePixels.length > 0) {
                    // 创建离屏canvas以提高性能
                    const lensCanvas = document.createElement('canvas');
                    lensCanvas.width = canvasWidth;
                    lensCanvas.height = canvasHeight;
                    const lensCtx = lensCanvas.getContext('2d');
                    
                    // 绘制镜片内部像素
                    lensCtx.fillStyle = '#3498db';
                    for (const pixel of surfaceData.insidePixels) {
                        lensCtx.fillRect(pixel.x, pixel.y, 1, 1);
                    }
                    
                    // 将离屏canvas绘制到主canvas
                    ctx.drawImage(lensCanvas, 0, 0);
                }
                
                // 绘制镜片描边
                if (showLensOutline) {
                    ctx.strokeStyle = '#2c3e50';
                    ctx.lineWidth = 2;
                    ctx.globalAlpha = 1.0;
                    
                    // 绘制前表面
                    if (surfaceData.frontPoints.length > 0) {
                        ctx.beginPath();
                        ctx.moveTo(surfaceData.frontPoints[0].x, surfaceData.frontPoints[0].y);
                        for (let i = 1; i < surfaceData.frontPoints.length; i++) {
                            ctx.lineTo(surfaceData.frontPoints[i].x, surfaceData.frontPoints[i].y);
                        }
                        ctx.stroke();
                    }
                    
                    // 绘制后表面
                    if (surfaceData.backPoints.length > 0) {
                        ctx.beginPath();
                        ctx.moveTo(surfaceData.backPoints[0].x, surfaceData.backPoints[0].y);
                        for (let i = 1; i < surfaceData.backPoints.length; i++) {
                            ctx.lineTo(surfaceData.backPoints[i].x, surfaceData.backPoints[i].y);
                        }
                        ctx.stroke();
                    }
                }
                
                // 恢复上下文状态
                ctx.restore();
            }
            
            // 计算光线与镜片的交点
            intersectWithRay(ray, isFront) {
                const surfaceX = isFront ? this.position : this.position + this.thickness;
                const curve = isFront ? this.frontCurve : this.backCurve;
                
                // 简化计算
                if (Math.abs(curve) < 0.001) {
                    // 平面镜片
                    const t = (surfaceX - ray.start.x) / ray.direction.x;
                    if (t > 0) {
                        const y = ray.start.y + ray.direction.y * t;
                        // 检查是否在镜片半径范围内
                        if (Math.abs(y - opticalAxisY) <= this.radius) {
                            return {
                                x: surfaceX,
                                y: y,
                                t: t,
                                normal: isFront ? { x: -1, y: 0 } : { x: 1, y: 0 }
                            };
                        }
                    }
                } else {
                    // 曲面镜片
                    const centerX = surfaceX + curve;
                    const radius = Math.abs(curve);
                    
                    const dx = ray.direction.x;
                    const dy = ray.direction.y;
                    const x0 = ray.start.x;
                    const y0 = ray.start.y;
                    const cx = centerX;
                    const cy = opticalAxisY;
                    
                    const A = dx*dx + dy*dy;
                    const B = 2*(dx*(x0 - cx) + dy*(y0 - cy));
                    const C = (x0 - cx)*(x0 - cx) + (y0 - cy)*(y0 - cy) - radius*radius;
                    
                    const discriminant = B*B - 4*A*C;
                    if (discriminant >= 0) {
                        const sqrtDisc = Math.sqrt(discriminant);
                        const t1 = (-B + sqrtDisc) / (2*A);
                        const t2 = (-B - sqrtDisc) / (2*A);
                        
                        const t = Math.min(t1 > 0 ? t1 : Infinity, t2 > 0 ? t2 : Infinity);
                        if (t < Infinity) {
                            const x = x0 + dx * t;
                            const y = y0 + dy * t;
                            
                            if (Math.abs(y - opticalAxisY) <= this.radius) {
                                const normalX = (x - cx) / radius;
                                const normalY = (y - cy) / radius;
                                const sign = curve > 0 ? 1 : -1;
                                return {
                                    x: x,
                                    y: y,
                                    t: t,
                                    normal: { x: normalX * sign, y: normalY * sign }
                                };
                            }
                        }
                    }
                }
                
                return null;
            }
            
            // 折射计算
            refractRay(ray, intersection, isFront) {
                const n1 = isFront ? 1.0 : this.refractiveIndex;
                const n2 = isFront ? this.refractiveIndex : 1.0;
                
                const incident = {
                    x: ray.direction.x,
                    y: ray.direction.y
                };
                
                const normal = intersection.normal;
                
                const cosI = - (incident.x * normal.x + incident.y * normal.y);
                const sinI2 = 1 - cosI * cosI;
                
                const nRatio = n1 / n2;
                const sinT2 = nRatio * nRatio * sinI2;
                
                if (sinT2 > 1.0) {
                    const cosR = 2 * cosI;
                    return {
                        x: incident.x + cosR * normal.x,
                        y: incident.y + cosR * normal.y
                    };
                }
                
                const cosT = Math.sqrt(1 - sinT2);
                
                const refracted = {
                    x: nRatio * incident.x + (nRatio * cosI - cosT) * normal.x,
                    y: nRatio * incident.y + (nRatio * cosI - cosT) * normal.y
                };
                
                const length = Math.sqrt(refracted.x * refracted.x + refracted.y * refracted.y);
                refracted.x /= length;
                refracted.y /= length;
                
                return refracted;
            }
        }
        
        // 光线类
        class Ray {
            constructor(startX, startY, wavelength) {
                this.start = { x: startX, y: startY };
                this.direction = { x: 1, y: 0 };
                this.wavelength = wavelength;
                this.segments = [];
                this.color = wavelengthToColor(wavelength);
            }
            
            // 追迹光线通过所有镜片
            trace(lenses) {
                this.segments = [];
                let currentPoint = { ...this.start };
                let currentDirection = { ...this.direction };
                
                this.segments.push({
                    start: { ...currentPoint },
                    end: null,
                    direction: { ...currentDirection }
                });
                
                const sortedLenses = [...lenses].sort((a, b) => a.position - b.position);
                
                for (const lens of sortedLenses) {
                    const frontIntersection = lens.intersectWithRay(
                        { start: currentPoint, direction: currentDirection }, 
                        true
                    );
                    
                    if (frontIntersection) {
                        this.segments[this.segments.length - 1].end = { 
                            x: frontIntersection.x, 
                            y: frontIntersection.y 
                        };
                        
                        currentDirection = lens.refractRay(
                            { direction: currentDirection }, 
                            frontIntersection, 
                            true
                        );
                        
                        currentPoint = { x: frontIntersection.x, y: frontIntersection.y };
                        
                        this.segments.push({
                            start: { ...currentPoint },
                            end: null,
                            direction: { ...currentDirection }
                        });
                        
                        const backIntersection = lens.intersectWithRay(
                            { start: currentPoint, direction: currentDirection }, 
                            false
                        );
                        
                        if (backIntersection) {
                            this.segments[this.segments.length - 1].end = { 
                                x: backIntersection.x, 
                                y: backIntersection.y 
                            };
                            
                            currentDirection = lens.refractRay(
                                { direction: currentDirection }, 
                                backIntersection, 
                                false
                            );
                            
                            currentPoint = { x: backIntersection.x, y: backIntersection.y };
                            
                            this.segments.push({
                                start: { ...currentPoint },
                                end: null,
                                direction: { ...currentDirection }
                            });
                        }
                    }
                }
                
                if (this.segments.length > 0) {
                    const lastSegment = this.segments[this.segments.length - 1];
                    if (!lastSegment.end) {
                        const t = (imagePlaneX - currentPoint.x) / currentDirection.x;
                        if (t > 0) {
                            lastSegment.end = {
                                x: imagePlaneX,
                                y: currentPoint.y + currentDirection.y * t
                            };
                        }
                    }
                }
            }
        }
        
        // 波长转换为颜色
        function wavelengthToColor(wavelength) {
            let r, g, b;
            
            if (wavelength >= 380 && wavelength < 440) {
                r = -(wavelength - 440) / (440 - 380);
                g = 0.0;
                b = 1.0;
            } else if (wavelength >= 440 && wavelength < 490) {
                r = 0.0;
                g = (wavelength - 440) / (490 - 440);
                b = 1.0;
            } else if (wavelength >= 490 && wavelength < 510) {
                r = 0.0;
                g = 1.0;
                b = -(wavelength - 510) / (510 - 490);
            } else if (wavelength >= 510 && wavelength < 580) {
                r = (wavelength - 510) / (580 - 510);
                g = 1.0;
                b = 0.0;
            } else if (wavelength >= 580 && wavelength < 645) {
                r = 1.0;
                g = -(wavelength - 645) / (645 - 580);
                b = 0.0;
            } else if (wavelength >= 645 && wavelength <= 700) {
                r = 1.0;
                g = 0.0;
                b = 0.0;
            } else {
                r = 1.0;
                g = 1.0;
                b = 1.0;
            }
            
            let factor;
            if (wavelength >= 380 && wavelength < 420) {
                factor = 0.3 + 0.7 * (wavelength - 380) / (420 - 380);
            } else if (wavelength >= 420 && wavelength < 700) {
                factor = 1.0;
            } else if (wavelength >= 700 && wavelength <= 780) {
                factor = 0.3 + 0.7 * (780 - wavelength) / (780 - 700);
            } else {
                factor = 1.0;
            }
            
            r = Math.floor(255 * Math.pow(r * factor, 0.8));
            g = Math.floor(255 * Math.pow(g * factor, 0.8));
            b = Math.floor(255 * Math.pow(b * factor, 0.8));
            
            return `rgb(${r}, ${g}, ${b})`;
        }
        
        // 加载默认配置
        function loadDefaultConfig() {
            try {
                const config = DEFAULT_CONFIG;
                
                // 清除现有镜片
                lenses = [];
                
                // 导入镜片
                if (config.lenses && Array.isArray(config.lenses)) {
                    config.lenses.forEach((lensConfig, index) => {
                        const lens = new Lens(
                            index + 1,
                            lensConfig.position,
                            lensConfig.thickness,
                            lensConfig.frontCurve,
                            lensConfig.backCurve,
                            lensConfig.refractiveIndex,
                            lensConfig.radius || 40
                        );
                        lens.name = lensConfig.name;
                        lenses.push(lens);
                    });
                }
                
                // 导入模拟设置
                if (config.simulation) {
                    if (config.simulation.startWavelength) {
                        startWavelength = config.simulation.startWavelength;
                        document.getElementById('startWavelength').value = startWavelength;
                        document.getElementById('startWavelengthValue').textContent = startWavelength;
                    }
                    
                    if (config.simulation.endWavelength) {
                        endWavelength = config.simulation.endWavelength;
                        document.getElementById('endWavelength').value = endWavelength;
                        document.getElementById('endWavelengthValue').textContent = endWavelength;
                    }
                    
                    if (config.simulation.rayDensity) {
                        rayDensity = config.simulation.rayDensity;
                        document.getElementById('rayDensity').value = rayDensity;
                        document.getElementById('rayDensityValue').textContent = rayDensity;
                    }
                    
                    if (config.simulation.rayOpacity) {
                        rayOpacity = config.simulation.rayOpacity;
                        document.getElementById('rayOpacity').value = rayOpacity;
                        document.getElementById('rayOpacityValue').textContent = rayOpacity.toFixed(1);
                    }
                    
                    if (config.simulation.lensOpacity) {
                        lensOpacity = config.simulation.lensOpacity;
                        document.getElementById('lensOpacity').value = lensOpacity;
                        document.getElementById('lensOpacityValue').textContent = lensOpacity.toFixed(1);
                    }
                    
                    if (config.simulation.showLensOutline !== undefined) {
                        showLensOutline = config.simulation.showLensOutline;
                        document.getElementById('lensOutline').checked = showLensOutline;
                    }
                    
                    if (config.simulation.blendMode) {
                        blendMode = config.simulation.blendMode;
                        document.getElementById('blendMode').value = blendMode;
                    }
                    
                    if (config.simulation.showGrid !== undefined) {
                        showGrid = config.simulation.showGrid;
                        document.getElementById('showGrid').checked = showGrid;
                    }
                    
                    if (config.simulation.gridSize) {
                        gridSize = config.simulation.gridSize;
                        document.getElementById('gridSize').value = gridSize;
                        document.getElementById('gridSizeValue').textContent = gridSize;
                    }
                    
                    if (config.simulation.darkMode !== undefined) {
                        darkMode = config.simulation.darkMode;
                        document.getElementById('darkMode').checked = darkMode;
                        if (darkMode) {
                            document.body.classList.add('dark-mode');
                        } else {
                            document.body.classList.remove('dark-mode');
                        }
                    }
                }
                
                selectedLensIndex = lenses.length > 0 ? 0 : -1;
                
                // 清除光线
                clearRays();
                
                // 更新界面
                updateLensList();
                updateLensParams();
                
                // 自动模拟
                simulateRays();
                
                // 将配置显示在JSON文本框中
                document.getElementById('jsonConfig').value = JSON.stringify(config, null, 2);
                
                // 隐藏加载指示器
                setTimeout(() => {
                    document.getElementById('loading').style.display = 'none';
                }, 500);
                
                return true;
            } catch (error) {
                console.error('加载默认配置失败:', error);
                alert('加载默认配置失败，将使用基本配置');
                return false;
            }
        }
        
        // 初始化
        function init() {
            canvas = document.getElementById('simulationCanvas');
            ctx = canvas.getContext('2d');
            
            canvas.width = canvasWidth;
            canvas.height = canvasHeight;
            
            // 加载默认配置
            const loadSuccess = loadDefaultConfig();
            
            if (!loadSuccess) {
                // 如果加载默认配置失败，使用基本配置
                addLens(200, 20, 50, -50, 1.5, 40);
                addLens(400, 15, 80, -80, 1.6, 35);
                addLens(600, 25, -60, 60, 1.7, 45);
                simulateRays();
                updateLensList();
                updateLensParams();
                render();
                
                // 隐藏加载指示器
                document.getElementById('loading').style.display = 'none';
            }
            
            // 绑定事件
            document.getElementById('addLensBtn').addEventListener('click', () => {
                addLens(300 + lenses.length * 50, 20, 50, -50, 1.5, 40);
                if (autoUpdate) {
                    clearRays();
                    simulateRays();
                }
                render();
                updateLensList();
            });
            
            document.getElementById('removeLensBtn').addEventListener('click', () => {
                if (selectedLensIndex >= 0 && selectedLensIndex < lenses.length) {
                    lenses.splice(selectedLensIndex, 1);
                    selectedLensIndex = -1;
                    if (autoUpdate) {
                        clearRays();
                        simulateRays();
                    }
                    render();
                    updateLensList();
                    updateLensParams();
                }
            });
            
            document.getElementById('simulateBtn').addEventListener('click', simulateRays);
            document.getElementById('clearRaysBtn').addEventListener('click', clearRays);
            
            document.getElementById('exportBtn').addEventListener('click', exportConfig);
            document.getElementById('importBtn').addEventListener('click', importConfig);
            
            // 光线密度滑块事件
            document.getElementById('rayDensity').addEventListener('input', (e) => {
                rayDensity = parseInt(e.target.value);
                document.getElementById('rayDensityValue').textContent = rayDensity;
                if (autoUpdate && rays.length > 0) {
                    simulateRays();
                }
            });
            
            // 透明度滑块事件
            document.getElementById('rayOpacity').addEventListener('input', (e) => {
                rayOpacity = parseFloat(e.target.value);
                document.getElementById('rayOpacityValue').textContent = rayOpacity.toFixed(1);
                if (rays.length > 0) {
                    render();
                }
            });
            
            // 镜片透明度滑块事件
            document.getElementById('lensOpacity').addEventListener('input', (e) => {
                lensOpacity = parseFloat(e.target.value);
                document.getElementById('lensOpacityValue').textContent = lensOpacity.toFixed(1);
                render();
            });
            
            // 镜片描边开关事件
            document.getElementById('lensOutline').addEventListener('change', (e) => {
                showLensOutline = e.target.checked;
                render();
            });
            
            // 混合模式选择事件
            document.getElementById('blendMode').addEventListener('change', (e) => {
                blendMode = e.target.value;
                if (rays.length > 0) {
                    render();
                }
            });
            
            // 波长范围事件
            document.getElementById('startWavelength').addEventListener('input', (e) => {
                startWavelength = parseInt(e.target.value);
                document.getElementById('startWavelengthValue').textContent = startWavelength;
                if (autoUpdate && rays.length > 0) {
                    simulateRays();
                }
            });
            
            document.getElementById('endWavelength').addEventListener('input', (e) => {
                endWavelength = parseInt(e.target.value);
                document.getElementById('endWavelengthValue').textContent = endWavelength;
                if (autoUpdate && rays.length > 0) {
                    simulateRays();
                }
            });
            
            // 网格控制事件
            document.getElementById('showGrid').addEventListener('change', (e) => {
                showGrid = e.target.checked;
                render();
            });
            
            document.getElementById('gridSize').addEventListener('input', (e) => {
                gridSize = parseInt(e.target.value);
                document.getElementById('gridSizeValue').textContent = gridSize;
                render();
            });
            
            // 暗色模式切换事件
            document.getElementById('darkMode').addEventListener('change', (e) => {
                darkMode = e.target.checked;
                if (darkMode) {
                    document.body.classList.add('dark-mode');
                } else {
                    document.body.classList.remove('dark-mode');
                }
                render();
            });
            
            // 模板按钮事件
            document.querySelectorAll('.template-btn').forEach(btn => {
                btn.addEventListener('click', () => {
                    const type = btn.getAttribute('data-type');
                    addTemplateLens(type);
                });
            });
            
            // 绑定滑块显示值更新
            document.getElementById('rayDensity').addEventListener('input', (e) => {
                document.getElementById('rayDensityValue').textContent = e.target.value;
            });
            
            document.getElementById('gridSize').addEventListener('input', (e) => {
                document.getElementById('gridSizeValue').textContent = e.target.value;
            });
            
            document.getElementById('startWavelength').addEventListener('input', (e) => {
                document.getElementById('startWavelengthValue').textContent = e.target.value;
            });
            
            document.getElementById('endWavelength').addEventListener('input', (e) => {
                document.getElementById('endWavelengthValue').textContent = e.target.value;
            });
            
            document.getElementById('lensOpacity').addEventListener('input', (e) => {
                document.getElementById('lensOpacityValue').textContent = parseFloat(e.target.value).toFixed(1);
            });
        }
        
        // 添加模板镜片
        function addTemplateLens(type) {
            let position, thickness, frontCurve, backCurve, refractiveIndex, radius;
            
            switch(type) {
                case 'convex':
                    position = 200 + lenses.length * 100;
                    thickness = 20;
                    frontCurve = 80;
                    backCurve = -80;
                    refractiveIndex = 1.5;
                    radius = 40;
                    break;
                case 'concave':
                    position = 200 + lenses.length * 100;
                    thickness = 20;
                    frontCurve = -80;
                    backCurve = 80;
                    refractiveIndex = 1.5;
                    radius = 40;
                    break;
                case 'plano-convex':
                    position = 200 + lenses.length * 100;
                    thickness = 20;
                    frontCurve = 100;
                    backCurve = 0;
                    refractiveIndex = 1.5;
                    radius = 40;
                    break;
                case 'plano-concave':
                    position = 200 + lenses.length * 100;
                    thickness = 20;
                    frontCurve = -100;
                    backCurve = 0;
                    refractiveIndex = 1.5;
                    radius = 40;
                    break;
                case 'meniscus':
                    position = 200 + lenses.length * 100;
                    thickness = 15;
                    frontCurve = 60;
                    backCurve = 30;
                    refractiveIndex = 1.6;
                    radius = 35;
                    break;
                case 'double-convex':
                    position = 200 + lenses.length * 100;
                    thickness = 25;
                    frontCurve = 70;
                    backCurve = -70;
                    refractiveIndex = 1.52;
                    radius = 45;
                    break;
                default:
                    position = 300 + lenses.length * 50;
                    thickness = 20;
                    frontCurve = 50;
                    backCurve = -50;
                    refractiveIndex = 1.5;
                    radius = 40;
            }
            
            addLens(position, thickness, frontCurve, backCurve, refractiveIndex, radius);
            
            if (lenses.length > 0) {
                const lens = lenses[lenses.length - 1];
                lens.name = `${type === 'convex' ? '凸' : type === 'concave' ? '凹' : type === 'plano-convex' ? '平凸' : type === 'plano-concave' ? '平凹' : type === 'meniscus' ? '弯月' : '双凸'}透镜 ${lens.id}`;
            }
            
            if (autoUpdate) {
                clearRays();
                simulateRays();
            }
            render();
            updateLensList();
        }
        
        // 添加镜片
        function addLens(position, thickness, frontCurve, backCurve, refractiveIndex, radius) {
            const id = lenses.length + 1;
            const lens = new Lens(id, position, thickness, frontCurve, backCurve, refractiveIndex, radius);
            lenses.push(lens);
            selectedLensIndex = lenses.length - 1;
            updateLensParams();
        }
        
        // 更新镜片列表
        function updateLensList() {
            const lensList = document.getElementById('lensList');
            
            if (lenses.length === 0) {
                lensList.innerHTML = '<p class="placeholder-text">暂无镜片，请点击"添加新镜片"或选择模板</p>';
                return;
            }
            
            lensList.innerHTML = '';
            
            lenses.forEach((lens, index) => {
                const lensItem = document.createElement('div');
                lensItem.className = `lens-item ${index === selectedLensIndex ? 'active' : ''}`;
                lensItem.innerHTML = `
                    <div class="lens-header">
                        <div class="lens-name">${lens.name}</div>
                        <div class="lens-actions">
                            <button class="select-lens" data-index="${index}">选择</button>
                            <button class="delete-lens" data-index="${index}">删除</button>
                        </div>
                    </div>
                    <div class="lens-details">
                        位置: ${lens.position.toFixed(1)} | 厚度: ${lens.thickness.toFixed(1)} | 折射率: ${lens.refractiveIndex.toFixed(2)}
                    </div>
                `;
                
                lensList.appendChild(lensItem);
                
                lensItem.querySelector('.select-lens').addEventListener('click', (e) => {
                    e.stopPropagation();
                    selectedLensIndex = parseInt(e.target.getAttribute('data-index'));
                    updateLensList();
                    updateLensParams();
                });
                
                lensItem.querySelector('.delete-lens').addEventListener('click', (e) => {
                    e.stopPropagation();
                    const index = parseInt(e.target.getAttribute('data-index'));
                    lenses.splice(index, 1);
                    
                    lenses.forEach((lens, i) => {
                        lens.id = i + 1;
                        if (lens.name.startsWith('镜片 ')) {
                            lens.name = `镜片 ${lens.id}`;
                        }
                    });
                    
                    if (selectedLensIndex >= index) selectedLensIndex--;
                    
                    if (lenses.length === 0) {
                        selectedLensIndex = -1;
                    }
                    
                    if (autoUpdate) {
                        clearRays();
                        simulateRays();
                    }
                    render();
                    updateLensList();
                    updateLensParams();
                });
                
                lensItem.addEventListener('click', (e) => {
                    if (!e.target.classList.contains('select-lens') && !e.target.classList.contains('delete-lens')) {
                        selectedLensIndex = index;
                        updateLensList();
                        updateLensParams();
                    }
                });
            });
        }
        
        // 更新镜片参数表单 - 全部改为小数类型
        function updateLensParams() {
            const lensParams = document.getElementById('lensParams');
            
            if (selectedLensIndex >= 0 && selectedLensIndex < lenses.length) {
                const lens = lenses[selectedLensIndex];
                
                lensParams.innerHTML = `
                    <div class="param-group">
                        <div class="param-item">
                            <label for="lensName">镜片名称</label>
                            <input type="text" id="lensName" value="${lens.name}">
                        </div>
                        <div class="param-item">
                            <label for="lensPosition">位置 (x)</label>
                            <input type="range" id="lensPosition" min="50" max="900" step="0.1" value="${lens.position}">
                            <span id="positionValue">${lens.position.toFixed(1)}</span>
                        </div>
                    </div>
                    <div class="param-group">
                        <div class="param-item">
                            <label for="lensThickness">厚度</label>
                            <input type="range" id="lensThickness" min="1" max="100" step="0.1" value="${lens.thickness}">
                            <span id="thicknessValue">${lens.thickness.toFixed(1)}</span>
                        </div>
                        <div class="param-item">
                            <label for="lensRadius">半径</label>
                            <input type="range" id="lensRadius" min="10" max="100" step="0.1" value="${lens.radius}">
                            <span id="radiusValue">${lens.radius.toFixed(1)}</span>
                        </div>
                    </div>
                    <div class="param-group">
                        <div class="param-item">
                            <label for="lensFrontCurve">前表面曲率</label>
                            <input type="range" id="lensFrontCurve" min="-200" max="200" step="0.1" value="${lens.frontCurve}">
                            <span id="frontCurveValue">${lens.frontCurve.toFixed(1)}</span>
                        </div>
                        <div class="param-item">
                            <label for="lensBackCurve">后表面曲率</label>
                            <input type="range" id="lensBackCurve" min="-200" max="200" step="0.1" value="${lens.backCurve}">
                            <span id="backCurveValue">${lens.backCurve.toFixed(1)}</span>
                        </div>
                    </div>
                    <div class="param-group">
                        <div class="param-item">
                            <label for="lensRefractiveIndex">折射率</label>
                            <input type="range" id="lensRefractiveIndex" min="1.0" max="2.0" step="0.01" value="${lens.refractiveIndex}">
                            <span id="refractiveIndexValue">${lens.refractiveIndex.toFixed(3)}</span>
                        </div>
                    </div>
                `;
                
                // 绑定滑块事件
                const positionSlider = document.getElementById('lensPosition');
                const thicknessSlider = document.getElementById('lensThickness');
                const radiusSlider = document.getElementById('lensRadius');
                const refractiveSlider = document.getElementById('lensRefractiveIndex');
                const frontCurveSlider = document.getElementById('lensFrontCurve');
                const backCurveSlider = document.getElementById('lensBackCurve');
                const nameInput = document.getElementById('lensName');
                
                positionSlider.addEventListener('input', (e) => {
                    document.getElementById('positionValue').textContent = parseFloat(e.target.value).toFixed(1);
                    updateLensParam('position', parseFloat(e.target.value));
                });
                
                thicknessSlider.addEventListener('input', (e) => {
                    document.getElementById('thicknessValue').textContent = parseFloat(e.target.value).toFixed(1);
                    updateLensParam('thickness', parseFloat(e.target.value));
                });
                
                radiusSlider.addEventListener('input', (e) => {
                    document.getElementById('radiusValue').textContent = parseFloat(e.target.value).toFixed(1);
                    updateLensParam('radius', parseFloat(e.target.value));
                });
                
                refractiveSlider.addEventListener('input', (e) => {
                    const value = parseFloat(e.target.value);
                    document.getElementById('refractiveIndexValue').textContent = value.toFixed(3);
                    updateLensParam('refractiveIndex', value);
                });
                
                frontCurveSlider.addEventListener('input', (e) => {
                    document.getElementById('frontCurveValue').textContent = parseFloat(e.target.value).toFixed(1);
                    updateLensParam('frontCurve', parseFloat(e.target.value));
                });
                
                backCurveSlider.addEventListener('input', (e) => {
                    document.getElementById('backCurveValue').textContent = parseFloat(e.target.value).toFixed(1);
                    updateLensParam('backCurve', parseFloat(e.target.value));
                });
                
                nameInput.addEventListener('input', (e) => {
                    updateLensParam('name', e.target.value);
                });
            } else {
                lensParams.innerHTML = '<p class="placeholder-text">选择一个镜片来编辑参数</p>';
            }
        }
        
        // 更新镜片参数
        function updateLensParam(param, value) {
            if (selectedLensIndex >= 0 && selectedLensIndex < lenses.length) {
                const lens = lenses[selectedLensIndex];
                lens[param] = value;
                
                // 清除表面缓存，因为参数已更改
                lens.surfaceCache = null;
                
                updateLensList();
                
                if (autoUpdate) {
                    clearRays();
                    simulateRays();
                }
                render();
            }
        }
        
        // 模拟光线
        function simulateRays() {
            clearRays();
            
            // 生成多条平行光
            const rayCount = rayDensity;
            const startYMin = opticalAxisY - 100;
            const startYMax = opticalAxisY + 100;
            
            // 计算波长范围
            const wavelengthRange = endWavelength - startWavelength;
            
            for (let i = 0; i < rayCount; i++) {
                // 在波长范围内均匀分布
                const rayWavelength = startWavelength + (wavelengthRange * i / Math.max(1, rayCount - 1));
                const startY = startYMin + (startYMax - startYMin) * i / Math.max(1, rayCount - 1);
                
                const ray = new Ray(50, startY, rayWavelength);
                ray.trace(lenses);
                rays.push(ray);
            }
            
            document.getElementById('rayCount').textContent = rays.length;
            render();
        }
        
        // 清除光线
        function clearRays() {
            rays = [];
            document.getElementById('rayCount').textContent = '0';
            render();
        }
        
        // 绘制网格
        function drawGrid() {
            if (!showGrid) return;
            
            ctx.strokeStyle = darkMode ? 'rgba(100, 100, 100, 0.3)' : 'rgba(200, 200, 200, 0.3)';
            ctx.lineWidth = 0.5;
            
            // 绘制垂直线
            for (let x = 0; x <= canvasWidth; x += gridSize) {
                ctx.beginPath();
                ctx.moveTo(x, 0);
                ctx.lineTo(x, canvasHeight);
                ctx.stroke();
                
                if (x % (gridSize * 5) === 0) {
                    ctx.lineWidth = 1;
                    ctx.stroke();
                    ctx.lineWidth = 0.5;
                }
            }
            
            // 绘制水平线
            for (let y = 0; y <= canvasHeight; y += gridSize) {
                ctx.beginPath();
                ctx.moveTo(0, y);
                ctx.lineTo(canvasWidth, y);
                ctx.stroke();
                
                if (y % (gridSize * 5) === 0) {
                    ctx.lineWidth = 1;
                    ctx.stroke();
                    ctx.lineWidth = 0.5;
                }
            }
            
            // 绘制光轴线
            ctx.strokeStyle = darkMode ? 'rgba(150, 150, 150, 0.5)' : 'rgba(150, 150, 150, 0.5)';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(0, opticalAxisY);
            ctx.lineTo(canvasWidth, opticalAxisY);
            ctx.stroke();
        }
        
        // 应用混合模式
        function applyBlendMode() {
            switch(blendMode) {
                case 'normal':
                    ctx.globalCompositeOperation = 'source-over';
                    break;
                case 'additive':
                    ctx.globalCompositeOperation = 'lighter';
                    break;
                case 'screen':
                    ctx.globalCompositeOperation = 'screen';
                    break;
            }
        }
        
        // 渲染场景
        function render() {
            // 清除画布
            if (darkMode) {
                ctx.fillStyle = '#000';
                ctx.fillRect(0, 0, canvasWidth, canvasHeight);
            } else {
                ctx.clearRect(0, 0, canvasWidth, canvasHeight);
            }
            
            // 绘制网格
            drawGrid();
            
            // 绘制成像平面
            ctx.beginPath();
            ctx.moveTo(imagePlaneX, opticalAxisY - 150);
            ctx.lineTo(imagePlaneX, opticalAxisY + 150);
            ctx.strokeStyle = '#e74c3c';
            ctx.lineWidth = 3;
            ctx.stroke();
            
            // 绘制成像平面标签
            ctx.fillStyle = darkMode ? '#e74c3c' : '#e74c3c';
            ctx.font = '14px Arial';
            ctx.fillText('成像平面', imagePlaneX - 40, opticalAxisY - 160);
            
            // 绘制镜片
            lenses.forEach((lens, index) => {
                const isSelected = index === selectedLensIndex;
                
                // 绘制镜片
                lens.draw(ctx);
                
                // 绘制镜片标签
                ctx.fillStyle = darkMode ? '#ecf0f1' : '#2c3e50';
                ctx.font = '12px Arial';
                ctx.fillText(lens.name, lens.position + 5, opticalAxisY - lens.radius - 10);
                ctx.fillText(`n=${lens.refractiveIndex.toFixed(2)}`, lens.position + 5, opticalAxisY - lens.radius - 25);
            });
            
            // 绘制光线
            if (rays.length > 0) {
                ctx.globalAlpha = rayOpacity;
                applyBlendMode();
                
                rays.forEach(ray => {
                    ctx.strokeStyle = ray.color;
                    ctx.lineWidth = 1.5;
                    
                    ray.segments.forEach(segment => {
                        if (segment.end) {
                            ctx.beginPath();
                            ctx.moveTo(segment.start.x, segment.start.y);
                            ctx.lineTo(segment.end.x, segment.end.y);
                            ctx.stroke();
                        }
                    });
                });
                
                ctx.globalAlpha = 1.0;
                ctx.globalCompositeOperation = 'source-over';
            }
            
            // 绘制光源
            ctx.fillStyle = '#f39c12';
            ctx.beginPath();
            ctx.arc(30, opticalAxisY, 15, 0, Math.PI * 2);
            ctx.fill();
            
            ctx.fillStyle = darkMode ? '#ecf0f1' : '#2c3e50';
            ctx.font = '12px Arial';
            ctx.fillText('光源', 15, opticalAxisY - 25);
        }
        
        // 导出配置为JSON
        function exportConfig() {
            const config = {
                lenses: lenses.map(lens => ({
                    name: lens.name,
                    position: lens.position,
                    thickness: lens.thickness,
                    frontCurve: lens.frontCurve,
                    backCurve: lens.backCurve,
                    refractiveIndex: lens.refractiveIndex,
                    radius: lens.radius
                })),
                simulation: {
                    startWavelength: startWavelength,
                    endWavelength: endWavelength,
                    rayDensity: rayDensity,
                    rayOpacity: rayOpacity,
                    lensOpacity: lensOpacity,
                    showLensOutline: showLensOutline,
                    blendMode: blendMode,
                    showGrid: showGrid,
                    gridSize: gridSize,
                    darkMode: darkMode
                }
            };
            
            document.getElementById('jsonConfig').value = JSON.stringify(config, null, 2);
        }
        
        // 导入配置
        function importConfig() {
            try {
                const jsonText = document.getElementById('jsonConfig').value;
                const config = JSON.parse(jsonText);
                
                lenses = [];
                
                if (config.lenses && Array.isArray(config.lenses)) {
                    config.lenses.forEach((lensConfig, index) => {
                        const lens = new Lens(
                            index + 1,
                            lensConfig.position,
                            lensConfig.thickness,
                            lensConfig.frontCurve,
                            lensConfig.backCurve,
                            lensConfig.refractiveIndex,
                            lensConfig.radius || 40
                        );
                        lens.name = lensConfig.name;
                        lenses.push(lens);
                    });
                }
                
                if (config.simulation) {
                    if (config.simulation.startWavelength) {
                        startWavelength = config.simulation.startWavelength;
                        document.getElementById('startWavelength').value = startWavelength;
                        document.getElementById('startWavelengthValue').textContent = startWavelength;
                    }
                    
                    if (config.simulation.endWavelength) {
                        endWavelength = config.simulation.endWavelength;
                        document.getElementById('endWavelength').value = endWavelength;
                        document.getElementById('endWavelengthValue').textContent = endWavelength;
                    }
                    
                    if (config.simulation.rayDensity) {
                        rayDensity = config.simulation.rayDensity;
                        document.getElementById('rayDensity').value = rayDensity;
                        document.getElementById('rayDensityValue').textContent = rayDensity;
                    }
                    
                    if (config.simulation.rayOpacity) {
                        rayOpacity = config.simulation.rayOpacity;
                        document.getElementById('rayOpacity').value = rayOpacity;
                        document.getElementById('rayOpacityValue').textContent = rayOpacity.toFixed(1);
                    }
                    
                    if (config.simulation.lensOpacity) {
                        lensOpacity = config.simulation.lensOpacity;
                        document.getElementById('lensOpacity').value = lensOpacity;
                        document.getElementById('lensOpacityValue').textContent = lensOpacity.toFixed(1);
                    }
                    
                    if (config.simulation.showLensOutline !== undefined) {
                        showLensOutline = config.simulation.showLensOutline;
                        document.getElementById('lensOutline').checked = showLensOutline;
                    }
                    
                    if (config.simulation.blendMode) {
                        blendMode = config.simulation.blendMode;
                        document.getElementById('blendMode').value = blendMode;
                    }
                    
                    if (config.simulation.showGrid !== undefined) {
                        showGrid = config.simulation.showGrid;
                        document.getElementById('showGrid').checked = showGrid;
                    }
                    
                    if (config.simulation.gridSize) {
                        gridSize = config.simulation.gridSize;
                        document.getElementById('gridSize').value = gridSize;
                        document.getElementById('gridSizeValue').textContent = gridSize;
                    }
                    
                    if (config.simulation.darkMode !== undefined) {
                        darkMode = config.simulation.darkMode;
                        document.getElementById('darkMode').checked = darkMode;
                        if (darkMode) {
                            document.body.classList.add('dark-mode');
                        } else {
                            document.body.classList.remove('dark-mode');
                        }
                    }
                }
                
                selectedLensIndex = lenses.length > 0 ? 0 : -1;
                
                clearRays();
                updateLensList();
                updateLensParams();
                simulateRays();
                
                alert('配置导入成功！');
            } catch (error) {
                alert('导入失败：JSON格式错误或配置不完整');
                console.error(error);
            }
        }
        
        // 页面加载完成后初始化
        window.addEventListener('DOMContentLoaded', init);
    </script>
</body>
</html>